esphome:
  name: ${name}
  name_add_mac_suffix: false
  friendly_name: ${friendly_name}

substitutions:
  name: bt-vevor_ble
  friendly_name: Diesel_Air_Heater

esp32_ble_tracker:

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:
  level: INFO

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_encryption_key

ota:
  platform: esphome
  password: !secret ota_password

# Web Server
# if you use home assistant and have frequent disconnections. disable the web_server
web_server:
  port: 80

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "VevorBLE Hotspot"
    password: "12345678"

interval:
  - interval: 10s
    id: heater_poll
    then:
      - logger.log: "Polling heater for telemetry..."
      - ble_client.ble_write:
          id: heater_ble
          service_uuid: 0000ffe0-0000-1000-8000-00805f9b34fb
          characteristic_uuid: 0000ffe1-0000-1000-8000-00805f9b34fb
          value: !lambda |-
            int pk = id(heater_passkey);
            uint8_t pass_hi = pk / 100;
            uint8_t pass_lo = pk % 100;
            uint8_t cmd = 0x01;
            uint8_t data_low = 0x00;
            uint8_t data_high = 0x00;
            uint8_t checksum = (pass_hi + pass_lo + cmd + data_low + data_high) & 0xFF;

            std::vector<uint8_t> payload = {0xAA, 0x55, pass_hi, pass_lo, cmd, data_low, data_high, checksum};
            ESP_LOGI("BLE", "send poll: %s", format_hex_pretty(payload).c_str());
            return payload;

ble_client:
  - mac_address: !secret mac_address
    id: heater_ble
    on_connect:
      - logger.log: "BLE connected to heater — waiting for telemetry"
    on_disconnect:
      - logger.log: "BLE disconnected"

globals:
  - id: heater_passkey
    type: int
    initial_value: !secret passkey

text_sensor:
  - platform: template
    id: glow_plug_status
    name: "Glow Plug Status"
    icon: "mdi:fire"

  - platform: template
    id: heater_mode_text
    name: "Heater Mode"
    icon: "mdi:thermometer"

  - platform: template
    id: temp_unit
    name: "Temperature Unit"
    icon: "mdi:thermometer"

  - platform: version
    hide_timestamp: true
    name: 'ESPHome Version'

  - platform: wifi_info
    ip_address:
      name: 'IP Address'
      icon: mdi:wifi
    ssid:
      name: 'Connected SSID'
      icon: mdi:wifi-strength-2

binary_sensor:
  - platform: template
    id: heater_status
    name: "Heater Running"
    device_class: power

# Sensors for status reporting
sensor:
  # System
  - platform: uptime
    name: "ESP Uptime"
    id: uptime_sensor

  # Heater Telemetry
  - platform: template
    id: error_code
    name: "Error Code"
    accuracy_decimals: 0
    icon: "mdi:alert-circle-outline"

  - platform: template
    id: battery_voltage
    name: "Battery Voltage"
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 1
    icon: "mdi:car-battery"

  - platform: template
    id: altitude
    name: "Altitude"
    unit_of_measurement: "m"
    device_class: distance
    accuracy_decimals: 0
    icon: "mdi:summit"

  - platform: template
    id: room_temperature
    name: "Cabin Temperature"
    unit_of_measurement: "°C"
    device_class: temperature
    accuracy_decimals: 1
    icon: "mdi:home-thermometer"

  - platform: template
    id: heating_temperature
    name: "Heater Core Temperature"
    unit_of_measurement: "°C"
    device_class: temperature
    accuracy_decimals: 1
    icon: "mdi:radiator"

  - platform: ble_client
    type: characteristic
    id: my_ble_sensor
    ble_client_id: heater_ble
    service_uuid: "0000ffe0-0000-1000-8000-00805f9b34fb"
    characteristic_uuid: "0000ffe1-0000-1000-8000-00805f9b34fb"
    name: "BLE Raw Data"
    notify: true
    lambda: |-
      auto raw = x;
      ESP_LOGI("BLE", "Raw frame (%d bytes): %s", raw.size(), format_hex_pretty(raw).c_str());

      // === Decrypt DA07 frames using repeating key "password" ===
      const uint8_t key[8] = {0x70, 0x61, 0x73, 0x73, 0x77, 0x6F, 0x72, 0x64};

      if (raw.size() == 48 && raw[0] == 0xDA && raw[1] == 0x07) {
        std::vector<uint8_t> dec(raw.size());
        for (size_t i = 0; i < raw.size(); i++) {
          dec[i] = raw[i] ^ key[i % 8];
        }

        ESP_LOGI("BLE", "Decrypted frame: %s", format_hex_pretty(dec).c_str());

        // === Parse as AA66 frame (based on full decode table) ===
        if (dec.size() >= 45 && dec[0] == 0xAA && dec[1] == 0x66) {
          auto U8  = [&](size_t i) -> uint8_t { return dec[i]; };
          auto S16 = [&](size_t hi, size_t lo) -> int16_t {
            int16_t val = (dec[hi] << 8) | dec[lo];
            if (val > 32767) val -= 65536;
            return val;
          };
          auto S8 = [&](size_t i) -> int8_t {
            int8_t val = dec[i];
            if (val > 127) val -= 256;
            return val;
          };

          // --- Basic fields ---
          uint8_t onOff = U8(3);
          uint8_t errcode = U8(4);
          uint8_t runStep = U8(5);
          uint8_t runMode = U8(8);

          // --- Temperature unit ---
          uint8_t tempByte = U8(27);
          uint8_t tempUnit = tempByte & 0x0F;

          // --- Set/run temp ---
          float runT = (tempUnit != 1) ? std::clamp<float>(U8(9), 8, 36) : std::clamp<float>(U8(9), 40, 99);
          uint8_t runG = std::clamp<uint8_t>(U8(10), 1, 10);

          // --- Voltage ---
          float voltage = (256.0f * U8(11) + U8(12)) / 10.0f;

          // --- Shell / Room temp ---
          float shellTemp = S16(13, 14);
          float roomTemp = S16(32, 33) / 10.0f;
          if (tempUnit == 1) {
              id(temp_unit).publish_state("F");
              runT = roundf((runT - 32) * 5 / 9);
          //  shellTemp = 1.8f * shellTemp + 32;
          //  roomTemp  = 1.8f * roomTemp + 32;
          } else {
              id(temp_unit).publish_state("C");
          }

          // --- Timing and auto ---
          int startTime = 256 * U8(19) + U8(20);
          int autoTime  = 256 * U8(21) + U8(22);
          int runTime   = 256 * U8(23) + U8(24);
          int isAuto    = U8(25);
          int8_t tempComp = S8(34);

          // --- Broadcast language / altitude unit ---
          uint8_t langVal = U8(26) & 0x0F;
          uint8_t altUnit = U8(30) & 0x0F;

          // --- Altitude ---
          float altitude_val = ((float)U8(7) + 256.0f * U8(6)) / 10.0f;
          float altitude_ft  = 3.3f * altitude_val;
          std::string altitude_str = (altUnit == 1)
            ? (altitude_ft >= 1000 ? str_sprintf("%.1fKft", altitude_ft / 1000.0f) : str_sprintf("%.0fft", (int)altitude_ft))
            : (altitude_val >= 1000 ? str_sprintf("%.1fKm", altitude_val / 1000.0f) : str_sprintf("%.0fm", (int)altitude_val));

          // --- Tank / pump / brightness ---
          uint8_t tankVolume = U8(28);
          uint8_t oilPumpType = U8(29);
          uint8_t brightness = U8(36);
          uint8_t autoVal = U8(31);

          // --- CO sensor ---
          int coActive = U8(37);
          int coPPM = 0;
          if (coActive == 1)
            coPPM = U8(39) + 256 * U8(38);

          // --- Part number & version ---
          uint32_t partNum = (U8(43) << 24) | (U8(42) << 16) | (U8(41) << 8) | U8(40);
          uint8_t motherboardVersion = U8(44);

          // --- Language name ---
          const char *langs[] = {"english", "chinese", "russian", "closeLan", "german"};
          std::string language = (langVal <= 4) ? langs[langVal] : "unknown";

          // --- Log all fields ---
          ESP_LOGI("BLE",
            "Decoded: onOff=%u err=%u step=%u mode=%u tempUnit=%u runT=%.1f runG=%u shell=%.1f room=%.1f°C volt=%.1fV alt=%s lang=%s part=0x%08X ver=%u co=%dppm",
            onOff, errcode, runStep, runMode, tempUnit, runT, runG, shellTemp, roomTemp, voltage, altitude_str.c_str(),
            language.c_str(), partNum, motherboardVersion, coPPM);

          // === Publish to Home Assistant ===
          id(battery_voltage).publish_state(voltage);
          id(altitude).publish_state(altitude_val);
          id(room_temperature).publish_state(roomTemp);
          id(heating_temperature).publish_state(shellTemp);
          id(error_code).publish_state(errcode);
          id(heater_status).publish_state(onOff > 0);
          id(heater_level).publish_state(runG);
          id(heater_temperature).publish_state(runT);

          // Optional text sensors / states
          if (runMode == 1) {
            id(heater_mode_text).publish_state("Level");
            id(heater_mode).publish_state("Level");
          } else if (runMode == 2) {
            id(heater_mode_text).publish_state("Automatic");
            id(heater_mode).publish_state("Automatic");
          } else {
            id(heater_mode_text).publish_state("Unknown");
          }

          if (runStep == 2 || runStep == 3) {
            id(glow_plug_status).publish_state("Heating");
          } else if (runStep == 4) {
            id(glow_plug_status).publish_state("Running");
          } else if (runStep == 5) {
            id(glow_plug_status).publish_state("Cooling Down");
          } else {
            id(glow_plug_status).publish_state("Idle");
          }

        } else {
          ESP_LOGW("BLE", "Decrypted frame not AA66 header, skipping parse");
        }

      } else if (raw.size() >= 13 && raw[0] == 0xAA && raw[1] == 0x55) {
        ESP_LOGI("BLE", "Short AA55 frame (status): %s", format_hex_pretty(raw).c_str());
      } else {
        ESP_LOGD("BLE", "Unhandled frame type or size (%d bytes)", raw.size());
      }

      // must return a float
      return 0;

  - platform: wifi_signal
    name: "WiFi Signal"
    update_interval: 120s

# Switches
switch:
  - platform: template
    id: heater_power
    name: "Heater Power"
    icon: "mdi:radiator"
    optimistic: true
    turn_on_action:
      - ble_client.ble_write:
          id: heater_ble
          service_uuid: "0000FFE0-0000-1000-8000-00805F9B34FB"
          characteristic_uuid: "0000FFE1-0000-1000-8000-00805F9B34FB"
          value: !lambda |-
            int pk = id(heater_passkey);
            uint8_t pass_hi = pk / 100;
            uint8_t pass_lo = pk % 100;
            uint8_t cmd = 0x03;
            uint8_t data_low = 0x01;
            uint8_t data_high = 0x00;
            uint8_t checksum = (pass_hi + pass_lo + cmd + data_low + data_high) & 0xFF;

            std::vector<uint8_t> payload = {0xAA, 0x55, pass_hi, pass_lo, cmd, data_low, data_high, checksum};
            ESP_LOGI("BLE", "send heat=on: %s", format_hex_pretty(payload).c_str());
            return payload;
    turn_off_action:
      - ble_client.ble_write:
          id: heater_ble
          service_uuid: "0000FFE0-0000-1000-8000-00805F9B34FB"
          characteristic_uuid: "0000FFE1-0000-1000-8000-00805F9B34FB"
          value: !lambda |-
            int pk = id(heater_passkey);
            uint8_t pass_hi = pk / 100;
            uint8_t pass_lo = pk % 100;
            uint8_t cmd = 0x03;
            uint8_t data_low = 0x00;
            uint8_t data_high = 0x00;
            uint8_t checksum = (pass_hi + pass_lo + cmd + data_low + data_high) & 0xFF;

            std::vector<uint8_t> payload = {0xAA, 0x55, pass_hi, pass_lo, cmd, data_low, data_high, checksum};
            ESP_LOGI("BLE", "send heat=off: %s", format_hex_pretty(payload).c_str());
            return payload;
    lambda: |-
      // For now, mirror the (future) heater_status binary sensor.
      return id(heater_status).state;

# Select for mode
select:
  - platform: template
    id: heater_mode
    name: "Heater Mode"
    options:
      - "Level"
      - "Automatic"
    initial_option: "Level"
    optimistic: true
    set_action:
      then:
        - if:
            condition:
              lambda: 'return id(heater_mode).state == "Automatic";'
            then:
              - logger.log: "Heater mode set to LEVEL"
              - ble_client.ble_write:
                  id: heater_ble
                  service_uuid: "0000FFE0-0000-1000-8000-00805F9B34FB"
                  characteristic_uuid: "0000FFE1-0000-1000-8000-00805F9B34FB"
                  value: !lambda |-
                    int pk = id(heater_passkey);
                    uint8_t pass_hi = pk / 100;
                    uint8_t pass_lo = pk % 100;
                    uint8_t cmd = 0x02;
                    uint8_t data_low = 0x01;
                    uint8_t data_high = 0x00;
                    uint8_t checksum = (pass_hi + pass_lo + cmd + data_low + data_high) & 0xFF;

                    std::vector<uint8_t> payload = {0xAA, 0x55, pass_hi, pass_lo, cmd, data_low, data_high, checksum};
                    ESP_LOGI("BLE", "send mode=level: %s", format_hex_pretty(payload).c_str());
                    return payload;

            else:
              - logger.log: "Heater mode set to AUTOMATIC"
              - ble_client.ble_write:
                  id: heater_ble
                  service_uuid: "0000FFE0-0000-1000-8000-00805F9B34FB"
                  characteristic_uuid: "0000FFE1-0000-1000-8000-00805F9B34FB"
                  value: !lambda |-
                    int pk = id(heater_passkey);
                    uint8_t pass_hi = pk / 100;
                    uint8_t pass_lo = pk % 100;
                    uint8_t cmd = 0x02;
                    uint8_t data_low = 0x02;
                    uint8_t data_high = 0x00;
                    uint8_t checksum = (pass_hi + pass_lo + cmd + data_low + data_high) & 0xFF;

                    std::vector<uint8_t> payload = {0xAA, 0x55, pass_hi, pass_lo, cmd, data_low, data_high, checksum};
                    ESP_LOGI("BLE", "send mode=auto: %s", format_hex_pretty(payload).c_str());
                    return payload;

number:
  - platform: template
    id: heater_temperature
    name: "Heater Temperature"
    unit_of_measurement: "°C"
    icon: "mdi:thermometer"
    min_value: 8
    max_value: 36
    step: 1
    optimistic: true
    set_action:
      then:
        - if:
            condition:
              lambda: 'return id(heater_mode).state != "Automatic";'
            then:
              - logger.log: "Switching to AUTOMATIC mode..."
              - ble_client.ble_write:
                  id: heater_ble
                  service_uuid: "0000FFE0-0000-1000-8000-00805F9B34FB"
                  characteristic_uuid: "0000FFE1-0000-1000-8000-00805F9B34FB"
                  value: !lambda |-
                    int pk = id(heater_passkey);
                    uint8_t pass_hi = pk / 100;
                    uint8_t pass_lo = pk % 100;
                    uint8_t cmd = 0x02;
                    uint8_t data_low = 0x02;
                    uint8_t data_high = 0x00;
                    uint8_t checksum = (pass_hi + pass_lo + cmd + data_low + data_high) & 0xFF;

                    std::vector<uint8_t> payload = {0xAA, 0x55, pass_hi, pass_lo, cmd, data_low, data_high, checksum};
                    ESP_LOGI("BLE", "send mode=auto: %s", format_hex_pretty(payload).c_str());
                    return payload;
              - delay: 1s

        # Send temperature setpoint (CMD=0x04)
        - ble_client.ble_write:
            id: heater_ble
            service_uuid: "0000FFE0-0000-1000-8000-00805F9B34FB"
            characteristic_uuid: "0000FFE1-0000-1000-8000-00805F9B34FB"
            value: !lambda |-
              uint8_t temp = (uint8_t)x;
              uint8_t adjusted;

              if (id(temp_unit).state == "F") {
                  adjusted = (uint8_t)roundf(temp * 9.0f / 5.0f + 32.0f);
                  ESP_LOGI("TEMP", "C=%d, Unit=F, sending %d°F", temp, adjusted);
              } else {
                  adjusted = temp;
                  ESP_LOGI("TEMP", "C=%d, Unit=C, sending %d°C", temp, adjusted);
              }

              int pk = id(heater_passkey);
              uint8_t pass_hi = pk / 100;
              uint8_t pass_lo = pk % 100;
              uint8_t cmd = 0x04;
              uint8_t data_low = adjusted;
              uint8_t data_high = 0x00;
              uint8_t checksum = (pass_hi + pass_lo + cmd + data_low + data_high) & 0xFF;

              std::vector<uint8_t> payload = {0xAA, 0x55, pass_hi, pass_lo, cmd, data_low, data_high, checksum};
              ESP_LOGI("BLE", "send temp=%d: %s", adjusted, format_hex_pretty(payload).c_str());
              return payload;

  # Level Setpoint (Level Mode)
  - platform: template
    id: heater_level
    name: "Heater Level"
    unit_of_measurement: "Level"
    icon: "mdi:format-list-numbered"
    min_value: 0
    max_value: 10
    step: 1
    optimistic: true
    set_action:
      then:
        - if:
            condition:
              lambda: 'return id(heater_mode).state != "Level";'
            then:
              - logger.log: "Switching to LEVEL mode..."
              - ble_client.ble_write:
                  id: heater_ble
                  service_uuid: "0000FFE0-0000-1000-8000-00805F9B34FB"
                  characteristic_uuid: "0000FFE1-0000-1000-8000-00805F9B34FB"
                  value: !lambda |-
                    int pk = id(heater_passkey);
                    uint8_t pass_hi = pk / 100;
                    uint8_t pass_lo = pk % 100;
                    uint8_t cmd = 0x02;
                    uint8_t data_low = 0x01;
                    uint8_t data_high = 0x00;
                    uint8_t checksum = (pass_hi + pass_lo + cmd + data_low + data_high) & 0xFF;

                    std::vector<uint8_t> payload = {0xAA, 0x55, pass_hi, pass_lo, cmd, data_low, data_high, checksum};
                    ESP_LOGI("BLE", "send mode=level: %s", format_hex_pretty(payload).c_str());
                    return payload;
              - delay: 1s

        # Send level setpoint (CMD=0x04)
        - ble_client.ble_write:
            id: heater_ble
            service_uuid: "0000FFE0-0000-1000-8000-00805F9B34FB"
            characteristic_uuid: "0000FFE1-0000-1000-8000-00805F9B34FB"
            value: !lambda |-
              uint8_t level = (uint8_t)x;
              int pk = id(heater_passkey);
              uint8_t pass_hi = pk / 100;
              uint8_t pass_lo = pk % 100;
              uint8_t cmd = 0x04;
              uint8_t data_low = level;
              uint8_t data_high = 0x00;
              uint8_t checksum = (pass_hi + pass_lo + cmd + data_low + data_high) & 0xFF;

              std::vector<uint8_t> payload = {0xAA, 0x55, pass_hi, pass_lo, cmd, data_low, data_high, checksum};
              ESP_LOGI("BLE", "send mode=level: %s", format_hex_pretty(payload).c_str());
              return payload;
